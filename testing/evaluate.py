"""evaluate.py

Script to create a system response for a given gold standard and then compare
the system response to that gold standard.

USAGE:

   $ python3 evaluate.py --run --gold DIR1 --system DIR2 [OPTIONS]
   $ python3 evaluate.py --comp --gold DIR1 --system DIR2 --html DIR3 [OPTIONS]

In the first invocation, the script takes the gold standard files in DIR1 and
for each file creates a system file in DIR2 that does not have the gold standard
tags but the tags generated by the system. In the second invocation, the script
compares the system results to the gold standard and writes precision, recall
and f-score results to the standard output and html files showing the difference
between files will be written to DIR3.

All files in the gold standard are expected to be TTK files. See the code in
utilities.convert for how to convert to the TTK format.

OPTIONS:

   --limit INT

      Caps the number of files processed from the directory. If no limit is
      given all files will be processed.

   --display=CHOICE1,CHOICE2,...

      This determines what entities pairs are displayed and is only relevant for
      the second invocation. By default all entity pairs from the gold and
      system tags are displayed: matches, partial matches, false positives and
      false negatives. But if the --display option is used then only the ones
      listed are displayed. Available choices are: EXACT_MATCH, PARTIAL_MATCH,
      NO_MATCH_FP and NO_MATCH_FN. Example:

         --display=NO_MATCH_FP,NO_MATCH_FN

      With this only false positives and false negatives are displayed.

The gold standard data in data/gold/timebank were created from the LDC
distribution of TimeBank using the conversion code in utilities/convert.py which
you run from the main ttk directory.

$ python -m utilities.convert --timebank2ttk TIMEBANK/data/extra data/gold/timebank

Here, TIMEBANK stands for the path to the LDC distribution. The converter uses
the "extra" directory rather then its sibling "timeml" since the former has some
metadata including the DCT.

"""

# TODO: this file needs major restructuring, see evaulate.md.


import os, sys, shutil, copy, getopt
from io import StringIO

sys.path.insert(0, '..')
sys.path.insert(0, '.')

import tarsqi
from library import timeml

from library.timeml import EVENT, TIMEX, ALINK, SLINK, TLINK, TID, EIID
from library.timeml import RELTYPE, TIME_ID, EVENT_INSTANCE_ID, RELATED_TO_TIME
from library.timeml import RELATED_TO_EVENT_INSTANCE, SUBORDINATED_EVENT_INSTANCE


LINK_TAGS = (ALINK, SLINK, TLINK)
TIMEML_TAGS = (EVENT, TIMEX, ALINK, SLINK, TLINK)


# Keep the directory this script was called from for later use (Tarsqi may
# change current directories while processing), also keep the directory of this
# script around.
EXEC_DIR = os.getcwd()
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))


# the four kinds of aligned entities
EXACT_MATCH = 'EXACT_MATCH'
PARTIAL_MATCH = 'PARTIAL_MATCH'
NO_MATCH_FP = 'NO_MATCH_FP'
NO_MATCH_FN = 'NO_MATCH_FN'
DISPLAY_CHOICES = [EXACT_MATCH, PARTIAL_MATCH, NO_MATCH_FP, NO_MATCH_FN]


# style file used for the html display of differences
CSS = """
<style>
div { display: block }
h2 { margin: 5pt; }
p { margin: 5pt; margin-bottom: 5pt; padding: 5pt; }
table { margin-bottom: 25px; margin-left: 10px; }
table.scores { margin: 10px; margin-bottom: 25px; width: auto; }
tr.average td { font-weight: bold; }
.bordered { border: thin dotted black; }
sup.s { color: darkred; font-weight: bold; }
sup.chunk { color: darkblue; font-weight: bold; }
sup.pos { color: darkblue; font-weight: bold; }
sup.lex { color: darkgreen; font-weight: bold; font-size: 60%; }
.bracket { color: darkblue; font-weight: bold; }
.sbracket { color: darkred; font-weight: bold; }
entity { color: darkred; text-decoration: underline; }")
</style>
"""


def create_system_files_from_gold_standard(gold_dir, system_dir, limit):
    """Take the TTK files in gold_dir and create TTK files in system_dir that have
    the same text and docelement tags, do not have the other tarsqi tags from
    the gold standard and have tags as added by the current system."""
    print(system_dir)
    if os.path.exists(system_dir):
        exit("Error: directory %s already exists" % system_dir)
    else:
        os.makedirs(system_dir)
    # get the absolute paths now because components may change the current directory
    gold_dir = os.path.abspath(gold_dir)
    system_dir = os.path.abspath(system_dir)
    count = 0
    for fname in os.listdir(gold_dir):
        count += 1
        if count > limit:
            break
        print(fname)
        gold_file = os.path.join(gold_dir, fname)
        system_file = os.path.join(system_dir, fname)
        create_system_file_from_gold_standard(gold_file, system_file)


def create_system_file_from_gold_standard(gold_file, system_file):
    """Take gold_file, a TTK file, and create the TTK file system_file that has
    the same text and docelement tags, does not have the other tarsqi tags from
    the gold standard and has tags as added by the current system."""
    # TODO: need to deal with the fact that with THYME we have a ttk version and
    # we use source=ttk, but there really needs to be a metadata parser that
    # does works for THYME documents. One option is to have the conversion find
    # the DCT.
    tarsqi_inst, tarsqidoc = tarsqi.load_ttk_document(gold_file)
    # before you reset, keep the docelement tags so that we do not have to rerun
    # the document parser
    docelement_tags = [t for t in tarsqidoc.tags.all_tags() if t.name == 'docelement']
    tarsqidoc.tags.reset()
    for tag in docelement_tags:
        tarsqidoc.tags.append(tag)
    tarsqidoc.tags.index()
    for (name, wrapper) in tarsqi_inst.pipeline:
        tarsqi_inst._apply_component(name, wrapper, tarsqidoc)
    tarsqidoc.print_all(system_file)


def compare_directories(gold_dir, system_dir, display_dir, display_choices,
                        limit=sys.maxsize):
    """Compare the gold and system drectories and create HTML files that view the
    differences."""
    fstats = []
    fnames = _collect_files(gold_dir, system_dir, limit)
    for fname in fnames:
        print(fname)
        fstats.append(FileStatistics(os.path.join(gold_dir, fname),
                                     os.path.join(system_dir, fname)))
    if display_dir is not None:
        display_dir = _create_display_dir(display_dir)
        for fstat in fstats:
            Viewer(fstat.events, display_dir, display_choices)
            Viewer(fstat.timexes, display_dir, display_choices)
    dstats = DirectoryStatistics(system_dir, fstats)
    dstats.pp()
    dstats.html(display_dir)


def _collect_files(gold_dir, system_dir, limit):
    """Return the list of files to run the comparison on."""
    gold_files = os.listdir(gold_dir)
    system_files = os.listdir(system_dir)
    # don't assume the directory content is the same, take the intersection;
    # this allows us to vary the gold files but get the system files from the
    # full list(this saves some space)
    return sorted(list(set(gold_files).intersection(set(system_files))))[:limit]


def _create_display_dir(display_dir):
    """Create the display directory and initialize it with the icons needed for
    the display."""
    if not os.path.isabs(display_dir):
        display_dir = os.path.abspath(os.path.join(EXEC_DIR, display_dir))
        if os.path.exists(display_dir):
            exit("ERROR: directory '%s' already exists" % display_dir)
        else:
            # set up the output directory
            os.makedirs(display_dir)
            os.makedirs(os.path.join(display_dir, 'icons'))
            icons = ('check-green.png', 'check-orange.png', 'cross-red.png')
            for icon in icons:
                shutil.copyfile(os.path.join(SCRIPT_DIR, 'icons', icon),
                                os.path.join(display_dir, 'icons', icon))
    return display_dir


def precision(tp, fp):
    try:
        return (tp / (tp + fp))
    except ZeroDivisionError:
        return None


def recall(tp, fn):
    try:
        return tp / (tp + fn)
    except ZeroDivisionError:
        return None


def fscore(tp, fp, fn):
    p = precision(tp, fp)
    r = recall(tp, fn)
    if p is None or r is None:
        return None
    try:
        return (2 * p * r) / (p + r)
    except ZeroDivisionError:
        return None


def float_string(f):
    """Takes a floating point number and returns it as a formatted string"""
    return "%.2f" % f if f is not None else 'nil'



class FileStatistics(object):

    def __init__(self, gold_file, system_file):
        tarsqi_instance, tarsqi_doc = tarsqi.load_ttk_document(gold_file)
        self.tarsqidoc_gold = tarsqi_doc
        tarsqi_instance, tarsqi_doc = tarsqi.load_ttk_document(system_file)
        self.tarsqidoc_system = tarsqi_doc
        self.filename = system_file
        self.gold = self._get_annotations(self.tarsqidoc_gold.tags)
        self.system = self._get_annotations(self.tarsqidoc_system.tags)
        self.events = EntityStatistics(self, EVENT)
        self.timexes = EntityStatistics(self, TIMEX)
        self.alinks = LinkStatistics(self.filename, ALINK, self.gold, self.system)
        self.slinks = LinkStatistics(self.filename, SLINK, self.gold, self.system)
        self.tlinks = LinkStatistics(self.filename, TLINK, self.gold, self.system)

    def __str__(self):
        return "%s\n%s\n%s\n%s\n%s" % (self.events, self.timexes,
                                       self.alinks, self.slinks, self.tlinks)

    def pp_annotations(self, annotations, tag=None):
        """Print the contents of self.gold or self.system (handed in with the
        annotations parameter."""
        for tagname in sorted(annotations):
            if tag is not None and tag != tagname:
                continue
            print("\n", tagname)
            for offsets in sorted(annotations[tagname]):
                attrs = annotations[tagname][offsets].items()
                attrs_str = ' '.join(["%s=%s" % (a,v) for a,v in attrs])
                print("  %s %s" % (offsets, attrs_str))

    def _get_annotations(self, tag_repository):
        """Return a dictionary of the TimeML annotations in the tag repository."""
        # build index of events and times
        idx = { EVENT:{}, TIMEX: {} }
        for tag in tag_repository.all_tags():
            if tag.name in (EVENT, TIMEX):
                idx[tag.name][tag.get_identifier()] = tag
        # get all TimeML annotation, anchored in offsets
        timeml_tags = (EVENT, TIMEX, ALINK, SLINK, TLINK)
        annotations = { tagname: {} for tagname in timeml_tags }
        for tag in tag_repository.all_tags():
            if tag.name in timeml_tags:
                offsets = self._get_offsets(tag, idx)
                if offsets is not None:
                    # TODO: this assumes only one tag per offset pair, use a list?
                    annotations[tag.name][offsets] = tag.attrs
        return annotations

    def _get_offsets(self, tag, idx):
        """Get begin and end offsets for the tag. For an event or time, this is a pair
        of offsets, for example (13,16). For a link, this is pair of the offsets of
        the source and target of the link, for example ((13,16),(24,29))."""
        if tag.name in LINK_TAGS:
            id1 = tag.attrs.get(TIME_ID,
                                tag.attrs.get(EVENT_INSTANCE_ID))
            id2 = tag.attrs.get(RELATED_TO_TIME,
                                tag.attrs.get(RELATED_TO_EVENT_INSTANCE,
                                              tag.attrs.get(SUBORDINATED_EVENT_INSTANCE)))
            type1 = EVENT if id1.startswith('ei') else TIMEX
            type2 = EVENT if id2.startswith('ei') else TIMEX
            tag1 = idx[type1].get(id1)
            tag2 = idx[type2].get(id2)
            if tag1 is None or tag2 is None:
                print("WARNING: cannot find source and/or target for", tag.as_ttk_tag())
                return None
            return ((tag1.begin, tag1.end), (tag2.begin, tag2.end))
        else:
            return (tag.begin, tag.end)


class DirectoryStatistics(FileStatistics):

    def __init__(self, directory, statslist):
        self.filename = directory
        self.statistics = statslist
        self.events = AggregateEntityStatistics(directory, [s.events for s in statslist])
        self.timexes = AggregateEntityStatistics(directory, [s.timexes for s in statslist])
        self.alinks = AggregateLinkStatistics(directory, [s.alinks for s in statslist])
        self.slinks = AggregateLinkStatistics(directory, [s.slinks for s in statslist])
        self.tlinks = AggregateLinkStatistics(directory, [s.tlinks for s in statslist])

    def __str__(self):
        return "%s\n%s\n%s\n%s\n%s" % (
            self.events, self.timexes, self.alinks, self.slinks, self.tlinks)

    def pp(self):
        print("\n%s\n" % self)

    def html(self, display_dir):
        with open(os.path.join(display_dir, 'index.html'), 'w') as fh:
            fh.write('<html>\n')
            fh.write("<html>\n<head>%s</head>\n\n" % CSS)
            fh.write('<body>\n')
            fh.write('<h2>Results for %s</h2>\n' % os.path.basename(self.filename))
            fh.write('<p>The second number in each column is for relaxed macthing.</p>\n')
            fh.write('<table cellpadding=5 cellspacing=0 border=1>\n')
            self._write_header_row(fh, '&nbsp;')
            self._write_row(fh, 'Events', self.events)
            self._write_row(fh, 'Timexes', self.timexes)
            fh.write('</table>\n')
            fh.write('<h2>Events</h2>\n')
            fh.write('<table cellpadding=5 cellspacing=0 border=1>\n')
            self._write_header_row(fh, '&nbsp;')
            for s in self.statistics:
                fname = os.path.basename(s.filename)
                header = '<a href="%s.EVENT.html">%s</a></td>\n' % (fname, fname)
                self._write_row(fh, header, s.events)
            fh.write('</table>\n')
            fh.write('<h2>Timexes</h2>\n')
            fh.write('<table cellpadding=5 cellspacing=0 border=1>\n')
            self._write_header_row(fh, '&nbsp;')
            for s in self.statistics:
                fname = os.path.basename(s.filename)
                header = '<a href="%s.TIMEX3.html">%s</a></td>\n' % (fname, fname)
                self._write_row(fh, header, s.timexes)
            fh.write('</table>\n')
            fh.write('</body>\n')
            fh.write('</html>\n')

    def _write_header_row(self, fh, text):
        fh.write('  <tr>\n')
        fh.write('    <td>%s</td>\n' % text)
        fh.write('    <td colspan=2>precision</td>\n')
        fh.write('    <td colspan=2>recall</td>\n')
        fh.write('    <td colspan=2>f-score</td>\n')
        fh.write('    <td colspan=2>tp</td>\n')
        fh.write('    <td colspan=2>fp</td>\n')
        fh.write('    <td colspan=2>fn</td>\n')
        fh.write('  </tr>\n')

    def _write_row(self, fh, header, stats):
        fh.write('  <tr>\n')
        fh.write('    <td>%s</a></td>\n' % header)
        for stat in (stats.precision, stats.precision_r, stats.recall,
                     stats.recall_r, stats.fscore, stats.fscore_r):
            fh.write('    <td align=right>%.2f</td>\n' % stat)
        for stat in (stats.tp, stats.tp_r, stats.fp, stats.fp_r, stats.fn, stats.fn_r):
            fh.write('    <td align=right>%s</td>\n' % stat)
        fh.write('  </tr>\n')


class EntityStatistics(object):

    def __init__(self, file_statistics, tagname):
        self.filename = file_statistics.filename
        self.tagname = tagname
        self.tarsqidoc_gold = file_statistics.tarsqidoc_gold
        self.tarsqidoc_system = file_statistics.tarsqidoc_system
        self.gold_tags = file_statistics.gold[self.tagname]
        self.system_tags = file_statistics.system[self.tagname]
        self._build_idxs()
        self._align_tags()
        # sets values for variables tp, fp, fn, precision, recall and fscore
        self._calculate_strict()
        # sets values for variables as the above, but now with _r suffix
        self._calculate_relaxed()

    def __str__(self):
        fname = os.path.basename(self.filename)
        tag = self.tagname[:5]
        p_strinct, p_relaxed = float_string(self.precision), float_string(self.precision_r)
        r_strinct, r_relaxed = float_string(self.recall), float_string(self.recall_r)
        f_strinct, f_relaxed = float_string(self.fscore), float_string(self.fscore_r)
        return (f"<Statistics {fname} {tag}" +
                f" precision={p_strinct}:{p_relaxed}" +
                f" recall={r_strinct}:{r_relaxed}" +
                f" recall={f_strinct}:{f_relaxed}"
                f" tp={self.tp}:{self.tp_r} fp={self.fp}:{self.fp_r} fn={self.fn}:{self.fn_r}>")

    def _build_idxs(self):
        """Builds indexes that store the begin and end offset of s, ng and vg
        tags. In addition, it stores the end offset of a lex tag and the lex
        tag's associated pos."""
        s_tags = self.tarsqidoc_system.tags.find_tags('s')
        vg_tags = self.tarsqidoc_system.tags.find_tags('vg')
        ng_tags = self.tarsqidoc_system.tags.find_tags('ng')
        lex_tags = self.tarsqidoc_system.tags.find_tags('lex')
        self.open_idx = { 's': set([t.begin for t in s_tags]),
                          'ng': set([t.begin for t in ng_tags]),
                          'vg': set([t.begin for t in vg_tags]) }
        self.close_idx = { 's': set([t.end for t in s_tags]),
                           'ng': set([t.end for t in ng_tags]),
                           'vg': set([t.end for t in vg_tags]),
                           'lex': {t.end: t.attrs['pos'] for t in lex_tags} }

    def _align_tags(self):
        """Takes two lists of annotations ordered on text position and returns
        them as lists of paired up annotations. Annotations will only pair up if
        they overlap, if a gold or system annotation does not overlap with a
        counterpart on the other side then it will be in a pair with None."""
        gold = [EntityAnnotation(k, v) for k, v in self.gold_tags.items()]
        system = [EntityAnnotation(k, v) for k, v in self.system_tags.items()]
        gold = self._sort_and_remove_duplicates(gold)
        system = self._sort_and_remove_duplicates(system)
        self.alignments = []
        while gold or system:
            if not gold:
                self.alignments.append(Alignment(self, None, system.pop(0)))
            elif not system:
                self.alignments.append(Alignment(self, gold.pop(0), None))
            elif gold[0].overlaps_with(system[0]):
                self.alignments.append(Alignment(self, gold.pop(0), system.pop(0)))
            elif gold[0].end < system[0].begin:
                self.alignments.append(Alignment(self, gold.pop(0), None))
            elif gold[0].begin > system[0].end:
                self.alignments.append(Alignment(self, None, system.pop(0)))
            else:
                exit("ERROR: no option available, infinite loop starting...")

    @staticmethod
    def _sort_and_remove_duplicates(annotations):
        """This is to remove duplicates from the annotations. The reason why
        this was put in is that with tag import there are cases when an imported
        tag spans two chunks and it will be imported into each chunk. This needs
        to be fixed in the tag import of course, but in the mean time we do not
        want it to dilute results here. The result is sorted on text position."""
        tmp = {}
        for annotation in sorted(annotations):
            tmp[annotation.offsets()] = annotation
        return sorted(tmp.values())

    def _calculate_strict(self):
        """Collect the counts for true positives, true negatives, false positives and
        false negatives, then calculate P&R. This calculates in a strict way,
        requiring exacts matches of entities."""
        # TODO. This does not take the full-range into account and therefore
        # gives much lower numbers for cases where multi-token events were
        # imported.
        self.tp = 0
        self.fp = 0
        self.fn = 0
        for t in self.system_tags.keys():
            if t in self.gold_tags:
                self.tp += 1
            else:
                self.fp += 1
        for t in self.gold_tags.keys():
            if t not in self.system_tags:
                self.fn += 1
        self.precision = precision(self.tp, self.fp)
        self.recall = recall(self.tp, self.fn)
        self.fscore = fscore(self.tp, self.fp, self.fn)

    def _calculate_relaxed(self):
        """Uses the alignments for calculating P&R. Does also calculate the strict
        numbers just for a check and will complain if the results there are not
        the same as what we got from _calculate_strict()."""
        tp1, fp1, fn1 = self._count_matches(strict=True)
        tp2, fp2, fn2 = self._count_matches(strict=False)
        if tp1 != self.tp or fp1 != self.fp or fn1 != self.fn:
            print("Warning: different values for strict match:")
            print('   ', self.tagname, self.tp, self.fp, self.fn)
            print('   ', self.tagname, tp1, fp1, fn1)
        self.tp_r = tp2
        self.fp_r = fp2
        self.fn_r = fn2
        self.precision_r = precision(tp2, fp2)
        self.recall_r = recall(tp2, fn2),
        self.fscore_r = fscore(tp2, fp2, fn2)

    def _count_matches(self, strict=True):
        tp, fp, fn = 0, 0, 0
        for alignment in self.alignments:
            if alignment.status == NO_MATCH_FP:
                fp += 1
            elif alignment.status == NO_MATCH_FN:
                fn += 1
            elif alignment.status == PARTIAL_MATCH:
                if strict:
                    fp += 1
                    fn += 1
                else:
                    tp += 1
            elif alignment.status == EXACT_MATCH:
                tp += 1
        return (tp, fp, fn)


class LinkStatistics(object):

    def __init__(self, filename, tagname, gold_annotations, system_annotations):
        self.filename = filename
        self.tagname = tagname
        self.gold_tags = gold_annotations[tagname]
        self.system_tags = system_annotations[tagname]
        self.overlap = self._overlap(self.gold_tags, self.system_tags)
        self.correct = 0
        self.incorrect = 0
        for offset in self.overlap:
            if self.gold_tags[offset][RELTYPE] == self.system_tags[offset][RELTYPE]:
                self.correct += 1
            else:
                self.incorrect += 1

    def __str__(self):
        accuracy = self.accuracy()
        astring = "nil" if accuracy is None else "%.2f" % accuracy
        return "<Statistics %s %s correct:%s incorrect:%s accuracy:%s>" % \
            (os.path.basename(self.filename), self.tagname, self.correct, self.incorrect, astring)

    @staticmethod
    def _overlap(annotations1, annotations2):
        """Now just gets the keys that both have in common, should include links where
        source and target are reversed."""
        return [val for val in annotations1 if val in annotations2]

    def accuracy(self):
        try:
            return self.correct / (self.correct + self.incorrect)
        except ZeroDivisionError:
            return None


class AggregateEntityStatistics(EntityStatistics):

    def __init__(self, directory, statistics_list):
        self.tagname = statistics_list[0].tagname
        self.filename = directory
        self.statistics = statistics_list
        self.tp = sum([stats.tp for stats in statistics_list])
        self.fp = sum([stats.fp for stats in statistics_list])
        self.fn = sum([stats.fn for stats in statistics_list])
        self.precision = precision(self.tp, self.fp)
        self.recall = recall(self.tp, self.fn)
        self.fscore = fscore(self.tp, self.fp, self.fn)
        self.tp_r = sum([stats.tp_r for stats in statistics_list])
        self.fp_r = sum([stats.fp_r for stats in statistics_list])
        self.fn_r = sum([stats.fn_r for stats in statistics_list])
        self.precision_r = precision(self.tp_r, self.fp_r)
        self.recall_r = recall(self.tp_r, self.fn_r)
        self.fscore_r = fscore(self.tp_r, self.fp_r, self.fn_r)

class AggregateLinkStatistics(LinkStatistics):

    def __init__(self, directory, statistics_list):
        self.tagname = statistics_list[0].tagname
        self.filename = directory
        self.statistics = statistics_list
        self.correct = sum([stats.correct for stats in statistics_list])
        self.incorrect = sum([stats.incorrect for stats in statistics_list])


class Viewer(object):

    """Creates the HTML files that show the differences between the entities in
    two files."""

    def __init__(self, entity_statistics, display_dir, display_choices):
        """Take the data from the EntityStatistics instance (which got most of those
        from the FileStatistics instance)."""
        self.stats = entity_statistics
        self.filename = entity_statistics.filename
        self.tagname = entity_statistics.tagname
        self.display_dir = display_dir
        self.display_choices = display_choices
        self.alignments = self.stats.alignments
        self._display_aligned_tags()

    def _display_aligned_tags(self):
        # NOTE: when we run this we are in the ttk directory, even though we
        # started in the testing subdirectory, adjust paths as needed
        fname = os.path.join(self.display_dir, os.path.basename(self.filename))
        fh = open("%s.%s.html" % (fname, self.tagname), 'w')
        fh.write("<html>\n<head>%s</head>\n\n" % CSS)
        fh.write("<body class=scores>\n\n")
        fh.write("<h2>Results on %s</h2>\n\n" % os.path.basename(self.filename))
        fh.write("<p><a href=%s>%s</a></p>\n" % (self.filename, self.filename))
        self._display_p_and_r(fh)
        self._display_legend(fh)
        for alignment in self.alignments:
            if self.display_choices[alignment.status]:
                alignment.html(fh)
        fh.write("</body>\n</html>\n")

    def _display_p_and_r(self, fh):
        fh.write("<table class=scores cellpadding=8 cellspacing=0 border=1>\n")
        nbsp, p_str, r_str, f_str, fs = '&nbsp;', 'precision', 'recall', 'f-score', float_string
        HTML.row(fh, [nbsp, 'strict', 'relaxed'])
        HTML.row(fh, [p_str, fs(self.stats.precision), fs(self.stats.precision_r)])
        HTML.row(fh, [r_str, fs(self.stats.recall), fs(self.stats.recall_r)])
        HTML.row(fh, [f_str, fs(self.stats.fscore), fs(self.stats.fscore_r)])
        fh.write("</table>\n\n")

    def _display_legend(self, fh):
        def img(src): return '<img src="icons/%s.png" height=20>' % src
        fh.write("<table class=scores cellpadding=8 cellspacing=0 border=1>\n")
        em = len([a for a in self.alignments if a.status == EXACT_MATCH])
        pm = len([a for a in self.alignments if a.status == PARTIAL_MATCH])
        fp = len([a for a in self.alignments if a.status == NO_MATCH_FP])
        fn = len([a for a in self.alignments if a.status == NO_MATCH_FN])
        HTML.row(fh, [img("check-green"), 'exact match', em])
        HTML.row(fh, [img("check-orange"), 'partial match', pm])
        HTML.row(fh, [img('cross-red') + 'p',
                      'mismatch, false positive (precision error)', fp])
        HTML.row(fh, [img('cross-red') + 'r',
                      'mismatch, false negative (recall error)', fn])
        fh.write("</table>\n")
        icons = { EXACT_MATCH: img('check-green'),
                  PARTIAL_MATCH: img('check-orange'),
                  NO_MATCH_FP: img('cross-red') + 'p',
                  NO_MATCH_FN: img('cross-red') + 'r' }
        showing = [icons[choice]
                   for choice in DISPLAY_CHOICES
                   if self.display_choices[choice] is True]
        fh.write("<p class=bordered>Showing:&nbsp;&nbsp;%s</p>\n"
                 % '&nbsp;&nbsp;'.join(showing))


class EntityAnnotation(object):

    """Simple interface for an entity annotation."""

    def __init__(self, offsets, attrs):
        self.begin = offsets[0]
        self.end = offsets[1]
        # we keep these around so we can use them for sorting
        self.begin_head = self.begin
        self.end_head = self.end
        self.attrs = attrs
        full_range = self.attrs.get('full-range')
        if full_range is not None:
            self.begin, self.end = [int(x) for x in full_range.split('-')]
        self.tarsqidoc = None  # filled in later by the Alignment instance

    def __str__(self):
        return "<EntityAnnotation %s:%s %s>" % (self.begin, self.end, self.attrs)

    def __eq__(self, other):
        return (self.begin == other.begin) \
            and (self.end == other.end) \
            and (self.begin_head == other.begin_head)

    def __ne__(self, other):
        return (self.begin != other.begin) \
            or (self.end != other.end) \
            or (self.begin_head != other.begin_head)

    def __lt__(self, other):
        return self._compare(other) < 0

    def __le__(self, other):
        return self._compare(other) <= 0

    def __gt__(self, other):
        return self._compare(other) > 0

    def __ge__(self, other):
        return self._compare(other) >= 0

    def _compare(self, other):
        # TODO: revisit this later, it is Python3 compliant, but that's about
        # the best you can say
        def comp(x, y):
            return (x > y) - (x < y)
        begin_comp = comp(self.begin, other.begin)
        if begin_comp != 0:
            return begin_comp
        end_comp = comp(self.end, other.end)
        if end_comp != 0:
            return end_comp
        return comp(self.begin_head, other.begin_head)

    def overlaps_with(self, other):
        return not (self.end <= other.begin or other.end <= self.begin)

    def has_same_span(self, other):
        return self.begin == other.begin and self.end == other.end

    def offsets(self):
        return (self.begin, self.end)


class Alignment(object):

    def __init__(self, entitystats, gold_annotation, system_annotation):
        self.tarsqidoc_gold = entitystats.tarsqidoc_gold
        self.tarsqidoc_system = entitystats.tarsqidoc_system
        self.gold_annotation = gold_annotation
        self.system_annotation = system_annotation
        self.open_idx = entitystats.open_idx
        self.close_idx = entitystats.close_idx
        if gold_annotation is not None:
            self.gold_annotation.tarsqidoc = self.tarsqidoc_gold
        if system_annotation is not None:
            self.system_annotation.tarsqidoc = self.tarsqidoc_system
        if self.gold_annotation is None:
            self.status = NO_MATCH_FP
        elif self.system_annotation is None:
            self.status = NO_MATCH_FN
        elif self.gold_annotation.has_same_span(self.system_annotation):
            self.status = EXACT_MATCH
        else:
            self.status = PARTIAL_MATCH

    def html(self, fh):
        def oneliner(text):
            return ' '.join(text.strip().split())
        image = self._get_status_image()
        p1, p2, text_span = self._get_span()
        span1 = self._get_span_with_entity(p1, text_span, self.gold_annotation)
        span2 = self._get_span_with_entity(p1, text_span, self.system_annotation)
        text = text_span.strip().replace("\n", "<br/>")
        tagged_fragment = self._get_tagged_fragment(p1, p2, text_span)
        fh.write("<table cellpadding=5 cellspacing=4>\n\n")
        fh.write("<tr>\n")
        fh.write("  <td valign=top width=40>%s </td>\n" % image)
        fh.write("  <td class=bordered>\n")
        fh.write("     <span class=entity_span><i>%s:%s</i></span><br/>\n" % (p1, p2))
        fh.write("     <span class=entity_span>%s</span><br/>\n" % oneliner(span1))
        fh.write("     <span class=entity_span>%s</span>\n" % oneliner(span2))
        fh.write("     <br/><br/>%s\n" % tagged_fragment.strip())
        fh.write("  </td>\n")
        fh.write("</tr>\n\n")
        fh.write("</table>\n\n")

    def _get_status_image(self):
        if self.status == EXACT_MATCH:
            return '<img src="icons/check-green.png" height=20>'
        elif self.status == PARTIAL_MATCH:
            return '<img src="icons/check-orange.png" height=20>'
        elif self.status == NO_MATCH_FP:
            return '<img src="icons/cross-red.png" height=20>p'
        elif self.status == NO_MATCH_FN:
            return '<img src="icons/cross-red.png" height=20>r'

    def _get_span(self):
        offsets = []
        for annotation in self.gold_annotation, self.system_annotation:
            if annotation is not None:
                offsets.extend([annotation.begin, annotation.end])
        offsets.sort()
        span_begin = offsets[0] - 50
        span_end =  offsets[-1] + 50
        if span_begin < 0:
            span_begin = 0
        if span_end > len(self.tarsqidoc_gold.sourcedoc.text):
            span_end = len(self.tarsqidoc_gold.sourcedoc.text) -1
        return (span_begin, span_end,
                self.tarsqidoc_gold.sourcedoc[span_begin:span_end])

    def _get_span_with_entity(self, p1, text_span, annotation):
        if annotation is None:
            return text_span
        else:
            a1 = annotation.begin - p1
            a2 = annotation.end - p1
            return "%s<entity>%s</entity>%s" \
                % (text_span[:a1], text_span[a1:a2], text_span[a2:])

    def _get_tagged_fragment(self, p1, p2, text):
        def tag(cl, text): return "<sup class=%s>%s</sup>" % (cl, text)
        def brc(cl, bracket): return "<span class=%s>%s</span>" % (cl, bracket)
        output = StringIO()
        for i in range(0, p2-p1):
            i_adjusted = i + p1
            if i_adjusted in self.open_idx['s']:
                output.write('%s' % brc('sbracket', '['))
            if i_adjusted in self.open_idx['ng']:
                output.write('%s' % brc('bracket', '['))
            if i_adjusted in self.open_idx['vg']:
                output.write('%s' % brc('bracket', '['))
            output.write(text[i])
            if i_adjusted + 1 in self.close_idx['lex']:
                output.write(tag('lex', self.close_idx['lex'][i_adjusted + 1]))
            if i_adjusted + 1 in self.close_idx['ng']:
                output.write('%s%s' % (brc('bracket', ']'), tag('chunk', 'ng')))
            if i_adjusted + 1 in self.close_idx['vg']:
                output.write('%s%s' % (brc('bracket', ']'), tag('chunk', 'vg')))
            if i_adjusted + 1 in self.close_idx['s']:
                output.write('%s%s' % (brc('sbracket', ']'), tag('s', 's')))
        return output.getvalue()


class HTML(object):

    """Utility class for printing HTML to a file handle."""
    
    @classmethod
    def row(self, fh, elements):
        fh.write("<tr>\n")
        for e in elements:
            align = ' align=right' if isinstance(e, int) else ''
            fh.write("   <td%s>%s\n" % (align, e))
        fh.write("</tr>\n")



if __name__ == '__main__':

    options = ['run', 'comp', 'gold=', 'system=', 'html=', 'display=', 'limit=']
    (opts, args) = getopt.getopt(sys.argv[1:], '', options)
    opts = { k:v for k,v in opts }

    gold = os.path.abspath(opts.get('--gold'))
    system = os.path.abspath(opts.get('--system'))
    limit = int(opts.get('--limit', sys.maxsize))
    html = opts.get('--html')
    display = opts.get('--display')
    if display is None:
        display_choices = { c:True for c in DISPLAY_CHOICES }
    else:
        display_choices = { c:False for c in DISPLAY_CHOICES}
        for choice in display.split(','):
            display_choices[choice] = True

    if '--run' in opts:
        create_system_files_from_gold_standard(gold, system, limit)
    elif '--comp' in opts:
        compare_directories(gold, system, html, display_choices, limit)
